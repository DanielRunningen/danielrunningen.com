__NUXT_JSONP__("/projects/ik-and-pathing-with-processing", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y){return {data:[{project:{slug:"ik-and-pathing-with-processing",description:q,title:"Inverted Kinematics and Pathing with Processing",descriptionInArticle:false,image:"PathingScorpion.png",imageAlt:"Image of a scorpion model in a map simulation.",readMore:h,tags:[{text:"Java",show:h},{text:"Processing",show:h},{text:t,show:h}],toc:[{id:u,depth:v,text:w},{id:x,depth:o,text:y},{id:z,depth:o,text:A},{id:B,depth:o,text:C},{id:D,depth:o,text:E},{id:F,depth:v,text:G}],body:{type:H,children:[{type:b,tag:d,props:{},children:[{type:a,value:q}]},{type:a,value:c},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This assignment was a bit rough for me, mostly because I attempted to combine both aspects of the project into one sketch. Because I wanted to do the whole thing with 3D rendering, this meant that the kinematics example I was looking at wouldn't translate well given the method I used for creating my agent model. I ended up spending a significant amount of time trying to get it to work, only to have to reverse course and simply submit a separate file for the IK simulation."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"That being said, I did end up with a neat looking model that articulates, just not well, and not with IK."}]},{type:a,value:c},{type:b,tag:I,props:{id:u},children:[{type:b,tag:f,props:{href:"#sketches",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:w}]},{type:a,value:c},{type:b,tag:p,props:{id:x},children:[{type:b,tag:f,props:{href:"#inverse-kinematics",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:y}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"For this sketch, we were tasked with creating a multi-node arm that could easily reach through a 2D plane. This part of the project was scaffolded off of the "},{type:b,tag:g,props:{},children:[{type:a,value:J}]},{type:a,value:" example file provided in class."}]},{type:a,value:c},{type:b,tag:K,props:{className:[L,M,N],width:O,height:P,src:"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FSLmGrjxg2dE?si=csUmvrCAHDpsaIWk",title:Q,frameBorder:R,allow:S,allowFullScreen:h},children:[]},{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:"Single-arm IK"}]},{type:a,value:" - This is the basis for this sketch. Allow a single arm with at least four joints to move smoothly in the simulation. The example file started with three joints (including the root) and three segments. Once all the variables were placed into arrays, it was easy enough to extend the number of joints."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:"Joint Limits"}]},{type:a,value:" - The second requirement of this simulation. Joints should only be allowed to rotate a specific amount in either dimension. Since the geometry of the arms is fairly uniform, and the baseline for each is along the axis of reflection for each piece, each segment of the arm is allowed to deflect in either direction up to a pre-defined amount. These values were hard-coded in an array for simplicity, since this was after the formal submission date."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:"User Interaction"}]},{type:a,value:" - I was also lucky enough to start from a file that draws a circle around the mouse pointer. The arm then reaches for the circle without the user needing to do anything more than hover their mouse."}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:p,props:{id:z},children:[{type:b,tag:f,props:{href:"#crowd-simulation",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:A}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This was the basis for what I "},{type:b,tag:s,props:{},children:[{type:a,value:"wanted"}]},{type:a,value:" to do for the whole project. The idea was to take the professor's "},{type:b,tag:g,props:{},children:[{type:a,value:T}]},{type:a,value:" and convert it into 3D, adding on top of it an agent that could reach towards an "},{type:b,tag:s,props:{},children:[{type:a,value:"actual"}]},{type:a,value:" goal. When creating the skeleton of the model, I went with the method that each bone's rotation and placement were based on their parent's. This is fine when the motion is controlled from the root out to the extremities, but IK does this backwards, needing the ability to set the positions of the parents end effectors. Since the actual end effectors in this system are derived from their rotational geometries, the math involved to get IK to work, as the professor mentioned, \"Several weeks of development.\""}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"So, here we are, a pretty model that does "},{type:b,tag:s,props:{},children:[{type:a,value:"not"}]},{type:a,value:" include IK, but at least can kinda traverse a randomly generated graph of a continuous space."}]},{type:a,value:c},{type:b,tag:K,props:{className:[L,M,N],width:O,height:P,src:"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002Fmw1CgLEFUMs?si=YzDAZ-Kb39s0yw4k",title:Q,frameBorder:R,allow:S,allowFullScreen:h},children:[]},{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:"Single Agent Navigation"}]},{type:a,value:" - There is a single agent, and it navigates it's environment. There is no explicit collision detection here since this can all be handled by the way that the map is generated. No paths are drawn between obstacles that would cause the bounding boxes to overlap. All of the obstacles here are spheres, but their bounding geometries use axis-aligned boxes, in the scenario where more complex models would be used. An example of the close pathing can be seen towards the end of the video."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:t}]},{type:a,value:" - I stuck with the example PRM model since I clearly didn't need more challenges to get this project up and running. All of the small, light-yellow domes are the nodes of the graph. All the black lines between them are valid links. Links are restricted to be within a specific length and nodes are encouraged to space out slightly. No nodes are generated inside of bounding geometries for the obstacles. No paths are generated for connections that would cause the agent's bounding box to overlap with the other boxes. The agent uses simple breadth-first search, same as the original example."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:"3D Rendering & Camera"}]},{type:a,value:" - This part was thanks again to the use of Liam Tyler's camera class as well as the additions made by the professor to select items in 3D space. The camera is placed at an angle to show of the 3D nature, but the previous controls still work. With the professor's additions, you can click about the floor to select a point for which the agent will do their best to navigate to."}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:p,props:{id:B},children:[{type:b,tag:f,props:{href:"#code-pack",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:C}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"For grading purposes, the code is available through "},{type:b,tag:f,props:{href:"https:\u002F\u002Fdrive.google.com\u002Ffile\u002Fd\u002F1vMMksfAUakKIu1mqf5fWD0Vz5_xi5LT-\u002Fview?usp=drive_link",rel:[U,V,W],target:X},children:[{type:a,value:"my university Google Drive folder"}]},{type:a,value:"."}]},{type:a,value:c},{type:b,tag:p,props:{id:D},children:[{type:b,tag:f,props:{href:"#resources",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:E}]},{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"In a moment of frustration, all of the vectors went away from the manual implementations we were using in prior projects into Processing's own "},{type:b,tag:g,props:{},children:[{type:a,value:"PVector"}]},{type:a,value:" class. They are roughly the same, but I was getting more consistent results."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Along with normal Java classes and functions, I utilized some "},{type:b,tag:g,props:{},children:[{type:a,value:"Math"}]},{type:a,value:" library calls."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"The "},{type:b,tag:g,props:{},children:[{type:a,value:"Camera.pde"}]},{type:a,value:" class for the \"crowd\" simulation was written by Liam Tyler and adapted by professor Guy to include a 3D pointer."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Professor Guy's example files for "},{type:b,tag:g,props:{},children:[{type:a,value:J}]},{type:a,value:" and "},{type:b,tag:g,props:{},children:[{type:a,value:T}]},{type:a,value:" were the basis of these sketches."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fwww.scratchapixel.com\u002Flessons\u002F3d-basic-rendering\u002Fminimal-ray-tracer-rendering-simple-shapes\u002Fray-box-intersection.html",rel:[U,V,W],target:X},children:[{type:a,value:"This article"}]},{type:a,value:" was also of great help for getting the ray and AABB collision working correctly."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:I,props:{id:F},children:[{type:b,tag:f,props:{href:"#closing-remarks",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:G}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"There were many small things that consumed time and made the possibility of doing what I had desired no longer feasible, which is a generally frustrating feeling. I felt like I'd spend several hours debugging a thing, only to start with a fresh slate and copy the same code over to find it suddenly working without issue. I don't claim that this was any kind of black magic, but I clearly ended up too deep in forest to see the trees frequently on this assignment, and only the most frustrating example was trying to implement IK through rotational and relative geometries."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"I think had I started from the IK example first and worked my way backwards from what I ended up doing, I may have been able to better plan out a structure that included better IK-safe algorithms that would work okay in the environment we were given. I would have liked also to take a stab at more collision detection methods with either AABB or more complex detection models, but that may have to be something I explore in my free time."}]}]},excerpt:{type:H,children:[{type:b,tag:d,props:{},children:[{type:a,value:q}]}]},dir:"\u002Fprojects",path:"\u002Fprojects\u002Fik-and-pathing-with-processing",extension:".md",createdAt:Y,updatedAt:Y}}],fetch:{},mutations:void 0}}("text","element","\n","p","li","a","code",true,"true",-1,"span","icon","icon-link","strong",3,"h3","This project was a combination of two smaller simulations as the third major assignment in CSCI 5611 - Animation and Planning in Games.","ol","em","Motion Planning","sketches",2,"Sketches","inverse-kinematics","Inverse Kinematics","crowd-simulation","\"Crowd\" Simulation","code-pack","Code Pack","resources","Resources","closing-remarks","Closing Remarks","root","h2","IK_1Frozen.pde","iframe","d-block","mx-auto","mb-4",560,315,"YouTube video player","0","accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share","PRM_Exercise_SingleFile.pde","nofollow","noopener","noreferrer","_blank","2023-11-16T03:54:22.119Z")));